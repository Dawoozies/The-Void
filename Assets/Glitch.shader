Shader "Unlit/Glitch"
{
    Properties
    {
		_AlphaCutoff ("Alpha Cutoff", Range(0.0, 1.0)) = 0.5
		_LineThreshold ("Line Threshold", Range(0.0, 3.0)) = 0.0
		_UseOriginalColor ("Use Original Color (0 = No || 1 = Yes)", integer) = 1
		_AberrationAmountX("Aberration Amount X", Range(0.0, 10.0)) = 0
		_AberrationAmountY("Aberration Amount Y", Range(0.0, 10.0)) = 0
		_RightStripeAmount("Right Stripe Amount", Float) = 1.0
		_RightStripeFill("Right Stripe Fill", Range(0.0, 1.0)) = 0.5
		_LeftStripeAmount("Left Stripe Amount",Float) = 1
		_LeftStripeFill("Left Stripe Fill", Range(0.0, 1.0)) = 0.5
		_DisplacementAmount("Displacement Amount", Vector) = (0,0,0,0)
		_WaveDisplacementFrequency("Wave Displacement Frequency", Float) = 10
		_PrimaryGlitchTypeOutput("Primary Glitch Output", integer) = 0
		_SecondaryGlitchTypeOutput("Secondary Glitch Output", integer) = 0
		_ArtifactOpacity("Artifact Opacity", Range(0,1)) = 0.0
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader{
		Tags{ 
			"RenderType"="Transparent" 
			"Queue"="Transparent"
		}

		Blend SrcAlpha OneMinusSrcAlpha

		ZWrite off
		Cull off

		Pass{

			CGPROGRAM

			#include "UnityCG.cginc"

			#pragma vertex vert
			#pragma fragment frag

			sampler2D _MainTex;
			float4 _MainTex_ST;

			float _AlphaCutoff;
			float _LineThreshold;
			int _UseOriginalColor;

			float _AberrationAmountX;
			float _AberrationAmountY;
			float _RightStripeAmount;
			float _RightStripeFill;
			float _LeftStripeAmount;
			float _LeftStripeFill;
			fixed4 _DisplacementAmount;
			float _WaveDisplacementFrequency;
			int _PrimaryGlitchTypeOutput;
			int _SecondaryGlitchTypeOutput;
			float _ArtifactOpacity;

			struct appdata{
				float4 vertex : POSITION;
				float2 uv : TEXCOORD0;
				fixed4 color : COLOR;
			};

			struct v2f{
				float4 position : SV_POSITION;
				float2 uv : TEXCOORD0;
				fixed4 color : COLOR;
			};
			float rand(float2 co){
				return frac(sin(dot(co, float2(12.9898,78.233)))*43758.5453);
			}
			v2f vert(appdata v){
				v2f o;
				o.position = UnityObjectToClipPos(v.vertex);
				o.uv = TRANSFORM_TEX(v.uv, _MainTex);
				o.color = v.color;
				return o;
			}
			fixed4 frag(v2f i) : SV_TARGET{
				fixed4 col = tex2D(_MainTex, i.uv);
				fixed4 output = fixed4(1,1,1,1);
				float magnitudeRGB = pow(col[0], 2)+pow(col[1], 2)+pow(col[2], 2);

				//This is for color override
				if(magnitudeRGB <= pow(_LineThreshold, 2))
				{
					//Sorry we want to know when the combinedRGB is near zero then we can say
					//this color must be black or close to it
					output[0] = 0;
					output[1] = 0;
					output[2] = 0;
					output[3] = step(_AlphaCutoff, col[3]);	
				}
				else
				{
					output[0] = i.color[0];
					output[1] = i.color[1];
					output[2] = i.color[2];
					output[3] = step(_AlphaCutoff, col[3])*i.color[3];
				}

				//If _UseOriginalColor == 1 then overwrite 0,1,2 entries with original color
				if(_UseOriginalColor == 1)
				{
					output[0] = col[0];
					output[1] = col[1];
					output[2] = col[2];
				}

				//Glitch effect
				fixed2 _AberrationAmount = fixed2(_AberrationAmountX, _AberrationAmountY);
				float stripesRight = floor(i.uv.y*_RightStripeAmount);
				stripesRight = step(_RightStripeFill, rand(float2(stripesRight, stripesRight)));
				float stripesLeft = floor(i.uv.y*_LeftStripeAmount);
				stripesLeft = step(_LeftStripeFill, rand(float2(stripesLeft, stripesLeft)));
				fixed4 waveDisplacement = lerp(fixed4(1,0,0,1),fixed4(0,1,0,1), (sin(i.uv.y*_WaveDisplacementFrequency)+1)/2);

				//fixed4 shiftedDisplacement = _DisplacementAmount + _DisplacementShiftAmount*sin(_Time*_DisplacementShiftSpeed);
				fixed2 displacementUV = (_DisplacementAmount.xy*stripesRight) - (_DisplacementAmount.xy*stripesLeft);
				displacementUV += (_DisplacementAmount.zw * floor(10*waveDisplacement.r)) - (_DisplacementAmount.zw * floor(10*waveDisplacement.g));
				float R = tex2D(_MainTex, i.uv+displacementUV+_AberrationAmount).r;
				float G = tex2D(_MainTex, i.uv+displacementUV).g;
				float B = tex2D(_MainTex, i.uv+displacementUV-_AberrationAmount).b;

				fixed4 finalCol = fixed4(R,G,B,output[3]);

				//Specifically replace the bright reds generated by the aberration
				if(finalCol[0] > finalCol[1] && finalCol[0] > finalCol[2])
				{
					if(finalCol[0] >= 0.8)
					{
						finalCol[0] = col[0];
						finalCol[1] = col[1];
						finalCol[2] = col[2];
						finalCol[3] = _ArtifactOpacity;
						if(_SecondaryGlitchTypeOutput == 1)
						{
							//Sine Divide
							return sin(finalCol / output);
						}
						else if(_SecondaryGlitchTypeOutput == 2)
						{
							//Half difference
							return finalCol-output/2;
						}
						else if(_SecondaryGlitchTypeOutput == 3)
						{
							return finalCol + output*finalCol;
						}
						else if(_SecondaryGlitchTypeOutput == 4)
						{
							return finalCol + finalCol/output;
						}
						else
						{
							return finalCol;
						}
					}
				}

				if(_PrimaryGlitchTypeOutput == 1)
				{
					//Sine Divide
					return sin(finalCol / output);
				}
				if(_PrimaryGlitchTypeOutput == 2)
				{
					//Half difference
					return finalCol-output/2;
				}
				if(_PrimaryGlitchTypeOutput == 3)
				{
					//Add + Multiply
					//Gives a hazy kind of effect
					return finalCol + output*finalCol;
				}
				if(_PrimaryGlitchTypeOutput == 4)
				{
					return finalCol + finalCol/output;
				}
				else
				{
					//Default
					return finalCol;
				}
				//return finalCol-output/2;
				//return finalCol-fixed4(output[0],output[1],output[2],0);
				//return finalCol + output*finalCol;
			}

			ENDCG
		}
	}
}
